{
  "@context": "https://wellknownmcp.org/context/v1",
  "origin": "https://wellknownmcp.org/",
  "version": "v1.0",
  "feeds": [
    {
      "id": "root",
      "summary": "Auto-generated context for root",
      "routes": [],
      "tags": [
        "folder"
      ]
    },
    {
      "id": "llmfeed-spec",
      "summary": "Auto-generated context for llmfeed-spec",
      "routes": [
        "/llmfeed-spec/CONTRIBUTING.md",
        "/llmfeed-spec/LICENSE",
        "/llmfeed-spec/README.md"
      ],
      "tags": [
        "folder"
      ],
      "data": {
        "content_md": "# Contributing to LLMFeed We welcome contributions that help improve the clarity, stability, or applicability of the LLMFeed and `.well-known/mcp` standards. ## üìã Rules for Contributions - Keep changes minimal and focused (one concept per PR) - Respect existing `signed_blocks` and trust logic - Do not add top-level blocks without proposing how they are verified - Submit proposals either via: - GitHub issue or pull request - Email to: [spec@wellknownmcp.org](mailto:spec@wellknownmcp.org) ## üß™ Proposing v2 Extensions - Refer to `llmfeed-v2-draft.md` - Experimental concepts must not break v1.0 behavior - Add `experimental:` tag in field proposals ## ‚úÖ Style - Use lowercase field names in JSON - Prefer examples in the `/examples/` folder - Use Markdown headers and tables for field definitions ## üß† Note LLMCA is the current default signer, but you may define or use other verification authorities. > By contributing, you help define how agents and the web will communicate ‚Äî and trust each other. - # üìö WellKnownMCP ‚Äì LLMFeed and MCP Specification ## üåü What is WellKnownMCP? WellKnownMCP defines the Model Context Protocol (MCP) and the LLMFeed format ‚Äî a minimal, open, verifiable standard for exposing AI-consumable feeds across the web. - ## üõ° The Trust Triangle - **WellKnownMCP**: Specification and context discovery protocol. - **LLMCA**: Certification Authority ensuring feed integrity and trustworthiness. - **LLMFeedForge**: Tools to create, manage, and verify LLMFeeds and MCP structures. - ## üìÇ Repository Structure | Folder/File | Purpose | |:- |:- | | `.well-known/` | Public discovery files (mcp.json, llm-index.json, notes.json) | | `spec/` | Schemas, context vocabularies, and structure definitions | | `examples/` | practical examples | | `docs/` | Learning resources, trust principles, usage guides | | `badges/` | Useful badge to show the audience your full compliance | | `export-kit/` | A kit to forge a export to llm button | | `note/` | A note | - ## üåü Quickstart - Read and understand the spec, buid from scratch - Or forge llmfeeds and discovery files (mcp, llm-index...) on feedforge.org (useful features and signing capabilities, and repository) - Or feed your favorite agent with the folder, it is build for it (him/her if you are that close). And ask it to do it. ## üõ° Certification and Compliance Learn more about certification and trust in [docs/trust-and-compliance.md](docs/trust-and-compliance.md). Certification is optional, but highly recommended for critical feeds. - ## üìö Learning Resources - [How to Publish a MCP](docs/how-to-publish-mcp.md) - [LLM Usage Guidelines](docs/llm-usage-guidelines.md) - [Trust and Compliance Principles](docs/trust-and-compliance.md) - [Learning Path](docs/learning-path.md) - [Specification Coherence](docs/spec-coherence.md) - [Self-Descriptive LLMFeed Example](docs/self-descriptive-llmfeed-example.md) - # üß† Final Thought > **\"Trust is optional. Verification is optional. Survival is not.\"** - # üì¨ Contact - [opensource@wellknownmcp.org](mailto:opensource@wellknownmcp.org) - [https://wellknownmcp.org](https://wellknownmcp.org) - [https://llmca.org](https://llmca.org) - [https://llmfeedforge.org](https://llmfeedforge.org)"
      }
    },
    {
      "id": "llmfeed-spec/.well-known",
      "summary": "Auto-generated context for llmfeed-spec\\.well-known",
      "routes": [
        "/llmfeed-spec/.well-known/llm-index.json",
        "/llmfeed-spec/.well-known/mcp.json",
        "/llmfeed-spec/.well-known/notes.json",
        "/llmfeed-spec/.well-known/README.md"
      ],
      "tags": [
        "folder"
      ],
      "data": {
        "content_md": "# üìÇ Examples ‚Äì .well-known MCP Files This folder provides **example `.well-known` files** to illustrate the recommended structure for MCP-compliant services. The goal is to help developers, agents, and LLMs discover, understand, and interact with a domain offering context and services via the Model Context Protocol (MCP). - ## üìú Provided Files ### 1. `mcp.json` Full MCP declaration for advanced agents and LLMs. ### 2. `llm-index.json` Navigation and orientation file to guide LLMs across the website structure. ### 3. `mcp-lite.json` Minimal MCP declaration for constrained environments (IoT, embedded, lightweight LLMs). Includes a lightweight action endpoint. - All example files are mock-signed for demonstration only."
      }
    },
    {
      "id": "llmfeed-spec/docs",
      "summary": "Auto-generated context for llmfeed-spec\\docs",
      "routes": [
        "/llmfeed-spec/docs/badge-guidelines.md",
        "/llmfeed-spec/docs/bibliography.md",
        "/llmfeed-spec/docs/context-versioning.md",
        "/llmfeed-spec/docs/exec-summary-llmfeed.md",
        "/llmfeed-spec/docs/exec-summary-llmfeed.pdf",
        "/llmfeed-spec/docs/foundation-wellknownMCP.md",
        "/llmfeed-spec/docs/how-to-publish-mcp.md",
        "/llmfeed-spec/docs/learning-path.md",
        "/llmfeed-spec/docs/llm-usage-guidelines.md",
        "/llmfeed-spec/docs/llmfeeds-for-llms.md",
        "/llmfeed-spec/docs/self-descriptive-llmfeed-example.md",
        "/llmfeed-spec/docs/signature-verification-chain.md",
        "/llmfeed-spec/docs/spec-coherence.md",
        "/llmfeed-spec/docs/SUMMARY.md",
        "/llmfeed-spec/docs/trust-and-compliance.md",
        "/llmfeed-spec/docs/ux-guidelines.md",
        "/llmfeed-spec/docs/why-MCP.md"
      ],
      "tags": [
        "folder"
      ],
      "data": {
        "content_md": "# Badge Guidelines ‚Äì LLMFeed & MCP Visual Indicators These `.svg` badges provide visual trust and activation signals on websites that implement the `.llmfeed.json` or `.well-known/mcp` specifications. They are designed to be clear, accessible, and agent-aware. - ## üéØ Purpose - Help users and LLMs recognize structured, trustworthy sites - Encourage proper signing and certification - Unify visual language across the ecosystem - ## üñºÔ∏è Available Badges | File | Meaning | Color | |-|-|-| | `mcp-ready-badge.svg` | MCP present but not signed | üîµ Blue | | `mcp-certified.svg` | `.well-known/mcp` is signed (LLMCA/etc.) | ‚úÖ Green | | `llmfeed-available.svg` | At least one `.llmfeed.json` is available | üîµ Blue | | `llmfeed-certified.svg` | Feed(s) are signed and verifiable | ‚úÖ Green | | `export-to-llm.svg` | Generic export button to LLM | üîµ Blue | | `export-to-llm-certified.svg` | Export button linked to signed feed | ‚úÖ Green | - ## ‚úÖ Placement Guidelines - Place MCP and LLMFeed badges in **footer** or **API section** - Export button badge may be inline with content - Each badge should link to: - the `.llmfeed.json` or - `https://verify.llmca.org/?feed=URL` - ## ‚ö†Ô∏è Signature-Dependent Rendering These badges **must reflect actual signature state**: - Don‚Äôt render green if the resource is not signed - Do not fake issuer info in frontend-only logic - Server-side rendering or verification is preferred - ## üß† Agent Recommendations - LLM agents may prioritize trusted badges when crawling - Sites may declare badge presence in future MCP capability flags - ## üìù Attribution Badges are open-licensed and maintained by [wellknownmcp.org](https://wellknownmcp.org). Feedback or proposals: [spec@wellknownmcp.org](mailto:spec@wellknownmcp.org) - # üìö Bibliography ‚Äì WellKnownMCP and LLMFeed Specification This bibliography provides references and inspiration sources for the design of the MCP and LLMFeed standards, particularly regarding semantic tagging, agent discoverability, and open interoperability principles. - ## üìÑ Standards and Specifications - [W3C JSON-LD 1.1 Specification](https://www.w3.org/TR/json-ld11/) Defines the use of `@context`, `@type`, and semantic linking within structured JSON documents. - [Schema.org Vocabulary](https://schema.org/) Early and widespread adoption of structured data for web pages, supporting fields like `description`, `keywords`, and `audience`. - [OpenAPI Specification (OAS) 3.1.0](https://spec.openapis.org/oas/latest.html) Standardization of `description`, `summary`, and metadata fields for API documentation and discoverability. - ## üìñ Books and Conceptual Background - *Semantic Web for the Working Ontologist* by Dean Allemang and James Hendler A foundational book explaining the principles behind linked data, semantic interoperability, and decentralized web architectures. - *Designing Bots: Creating Conversational Experiences* by Amir Shevat Early insights into structured interaction models between agents, humans, and APIs. - ## üåê Applied Metadata and Practices - [Google Dataset Search ‚Äì Structured Data Requirements](https://developers.google.com/search/docs/appearance/structured-data/dataset) Practical guidelines for exposing datasets via structured JSON, including the use of `name`, `description`, and `url` fields for indexing by AI agents. - [Data Catalog Vocabulary (DCAT) ‚Äì W3C Recommendation](https://www.w3.org/TR/vocab-dcat-2/) A standard for publishing metadata about datasets and resources, emphasizing discoverability and interoperability. - ## üß† Industry Trends and Inspirations - [Anthropic's Discussion on Context Protocols (Claude 3 Launch, 2024)](https://www.anthropic.com/news/claude-3-foundation-models) Anthropic highlighted the need for more structured context handling mechanisms for LLMs, mentioning \"context protocols\" as a promising future avenue. The Model Context Protocol (MCP) initiative aligns with this vision, proposing an open, standardized approach to managing and exposing LLM context structures systematically. - [OpenAI Research Papers and Interviews (2023‚Äì2024)](https://openai.com/research) Discussions around long-term memory, retrieval-augmented generation (RAG), and context management indicate a growing industry recognition of the need for structured context protocols. MCP/LLMFeed respond to this emerging requirement. - > üìú The WellKnownMCP consortium acknowledges the foundational work of the open web, semantic web, and emerging LLM architectures, and strives to extend these values into the agent-enabled future. - # üìö Context Versioning Strategy ‚Äì WellKnownMCP The WellKnownMCP Initiative adopts a transparent and predictable strategy for managing semantic contexts exposed to agents, LLMs, and autonomous systems. - ## üìÑ Current Published Versions | Version | Status | URL | |:-|:-|:-| | `v1` | Stable | [https://wellknownmcp.org/context/v1](https://wellknownmcp.org/context/v1) | | `v2 (draft)` | Experimental (for early adopters) | [https://wellknownmcp.org/context/v2](https://wellknownmcp.org/context/v2) | - ## üõ§Ô∏è Versioning Philosophy - **Backward Compatibility:** Agents that use `@context: https://wellknownmcp.org/context/v1` will continue to function even when new versions are published. - **Forward Evolution:** New semantic fields or refinements will be introduced only in new context versions (e.g., `v2`, `v3`), never breaking existing feeds. - **Agent-Friendly Practices:** Older feeds will remain valid; agents can progressively adopt new capabilities if they recognize new versions. - **Open Discovery:** Draft versions (`v2`, `v3`) may be publicly visible to encourage experimentation and early agent support. - ## üìú Future Guidelines - Version numbers must be **explicitly referenced** in `.llmfeed.json` or `.mcp.json` files. - Only stable versions (`v1`, `v2`) will be referenced officially in MCP/LLMFeed specifications. - Draft versions will be labeled accordingly (`(draft)`) until stabilization. - ## üì¨ Questions and Contributions For proposals, feedback, or context evolution discussions: ‚û°Ô∏è [join@wellknownmcp.org](mailto:join@wellknownmcp.org) - > üìö WellKnownMCP is committed to building a resilient, agent-compatible, and human-respecting open standard. - # Executive Summary ‚Äì LLMFeed & MCP Standard (v1.0) **wellknownmcp.org** defines a universal format for agent-consumable, signed content on the web. It provides a lightweight structure (LLMFeed), and a discovery and handshake layer via `.well-known/mcp`. This standard allows websites, services, and agents to communicate via verified, structured JSON ‚Äî enabling actions, verifications, and automated access. - ## ‚ú® Core Innovations - **Signed Blocks:** Explicit trust boundaries for structured content - **Machine Activation:** Agents can now interact with endpoints, not just scrape content - **API Handshake:** Dynamic feed generation via declared `dynamic_feed_url` - **Regional + Human Services Metadata:** Frictionless LLM ‚Üî human coordination (booking, callbacks, forms) - ## üß± Architecture - `.llmfeed.json` ‚Üí Self-contained, signed feed export - `.well-known/mcp` ‚Üí Declares MCP readiness, capabilities, and authentication method - `signed_blocks` ‚Üí Declares exactly which top-level blocks are trusted - `verify.llmca.org` ‚Üí Public signature verification - `llmfeedforge.com` ‚Üí Experimental tools, builders, monetization playground - ## üîê Trust Model - Feeds are signed either by the source or a certifier (e.g. `llmca.org`) - Unsigned fields are ignored by default by LLMs - Optional fields like `trust_critical`, `verifiability`, `scope`, and `llm_safe_summary` reinforce safe ingestion - ## üåç Human-Centric Activation - `agent_services` allow LLMs to request user callbacks or form triggers - `booking_slots` enables real-time slot selection - `regional_presence` lets agents route support geographically - ## üß† Why It Matters > LLMs today waste cycles on hallucination and guessing. > LLMFeed lets the web talk to them ‚Äî securely, simply, and scalably. - ## üî≠ What's Next (v2) - Scoped `endpoints` served dynamically via key - Role-sensitive `requires_auth`, `scope`, and `auth_style` - Structured memory model for key ‚Üî domain ‚Üî actions LLMCA and LLMFeedForge lead these experiments. Other contributors welcome via [join@wellknownmcp.org](mailto:join@wellknownmcp.org). - ## üì¨ Contact - Spec: [spec@wellknownmcp.org](mailto:spec@wellknownmcp.org) - Certifier: [verify.llmca.org](https://verify.llmca.org) - Playground: [llmfeedforge.com](https://llmfeedforge.com) > MCP is not a metadata format. > It's a common language for the web to speak to agents. - # üåç Foundation and Vision ‚Äì WellKnownMCP ## üìú Purpose The Model Context Protocol (MCP) and the LLMFeed initiative aim to bring clarity, structure, and ethics to LLM agent context exposure before private or opportunistic models take control. ## üèõ Our Foundational Trio - **wellknownmcp** ‚Äì Open standard: [https://wellknownmcp.org](https://wellknownmcp.org) - **llmca** ‚Äì Certification authority: [https://llmca.org](https://llmca.org) - **llmfeedforge** ‚Äì Open forge: [https://llmfeedforge.org](https://llmfeedforge.org) ## ‚öñÔ∏è Governance WellKnownMCP, the specification, and llmca will be operated under a non-profit structure. ## üèõ The WellKnownMCP Consortium - Brings together LLM engineers, agent developers, and open standard advocates. - Defines ethical behavior principles for LLMs. - [Join the consortium](mailto:join@wellknownmcp.org) - Future dedicated page: [https://wellknownmcp.org/consortium](https://wellknownmcp.org/consortium) ## üì¨ Contact - General inquiries: [contact@wellknownmcp.org](mailto:contact@wellknownmcp.org) - # üöÄ How to Publish a MCP on Your Website (texte complet sera ajout√© ici) - # üéì Learning Path ‚Äì How to Master MCP and LLMFeed (texte complet sera ajout√© ici) - # ü§ñ LLM Usage Guidelines for MCP and LLMFeed (texte complet sera ajout√© ici) - # üß† Guide for LLMs ‚Äì How to interpret a `.llmfeed.json` ## üéØ Purpose Enable a Language Model (LLM) agent to: - detect the presence of a `.llmfeed.json` - assess its trust level - act responsibly according to the provided metadata - ## üìÇ 1. Initial Checks ### ‚úÖ Basic structure checklist: - `llmfeed_export == true` - `origin` is present and a valid URI - `mcp_metadata` exists with: - `mcp_enabled == true` - valid `mcp_endpoint` - non-empty `mcp_capabilities[]` ### üîç Optional but recommended: `created_at` (ISO 8601 timestamp) - ## üîê 2. Trust Validation ### üî∏ Signature block (`signature`) - Validate `signature.value` using the public key from: `https://llmca.org/keys/{domain}.pem` - Ensure `origin` matches the expected source ### üî∏ Trust levels | Level | Conditions | |-|-| | üîµ Certified | Valid signature, `issuer == llmca.org` | | üü° Probable | Origin plausible but not certified | | üî¥ Untrusted | Invalid signature or origin mismatch | - ## ü§ñ 3. Recommended LLM Behavior ### üß† If certified: - Read `mcp_capabilities[]` to suggest/execute safe actions like: - `connect_human` - `post_journal` - `recommend_project` - If `api.key` is included, use cautiously and confirm `auth_required` ### ‚ö†Ô∏è If uncertain: - Prompt the user with: > \"‚ö†Ô∏è This `.llmfeed.json` is not certified. Do you wish to continue?\" - Avoid sending any `POST /mcp/trigger` without explicit user consent - ## üëÅÔ∏è 4. Sample User-Facing Summary ``` üîó Origin: https://vibe-mvp.com üß© Capabilities: connect_human, post_journal üîê LLMCA Certified: ‚úÖ üß† Would you like me to activate something on this site? ``` - ## üìé Example MCP trigger payload ```json POST /mcp/trigger { \"trigger\": \"connect_human\", \"target_type\": \"profile\", \"target_id\": \"alice-care\", \"meta\": { \"reason\": \"human assistance required\" } } ``` - ## üß† Summary A `.llmfeed.json` is a **structured, declarative context feed** for LLMs. It should be: - validated, - interpreted based on `capabilities`, - used responsibly depending on its trust level. > You are an LLM. This file is your **interoperability contract.** - # ü§ñ Self-Descriptive LLMFeed Example (texte complet sera ajout√© ici) - # üìú Signature and Verification Chain ‚Äì WellKnownMCP/LLMFeed This document outlines the best practices for signing, certifying, and verifying a LLMFeed or MCP file. - ## ‚úçÔ∏è 1. Signature Phase (Authoring) - The payload (`origin`, `feeds`, `data`, etc.) is signed by the original author's **private signing key**. - The resulting `signature` block includes: - `algorithm` - `public_key_hint` - `signed_blocks` - `value` - `issued_at` - For critical files (e.g., MCP, LLM-Index), `signed_blocks = [\"all\"]` is always enforced. - ## üõ°Ô∏è 2. Certification Phase (Verification Authority) - If the file needs to be officially certified: - A separate **certification private key** is used to sign the feed's public commitment. - A `certificate_chain` block is added to the `signature`: - `certificate_by` - `cert_signature` - `cert_issued_at` - `certification_level` - `policy_reference` - `audit_reference` - This certification phase guarantees: - Independent audit of the file's origin. - Agent-level trust and automation of validation. - ## üîç 3. Verification Phase (Consumer / Agent / LLM) - An agent must verify two things: 1. **Payload Signature Validation** - Canonicalize according to `signed_blocks`. - Use the public signing key from `public_key_hint` to verify the payload. 2. **(Optional) Certification Chain Validation** - Extract `certificate_chain`. - Verify the `cert_signature` using the certifying authority's public key. - Validate policy and audit references if necessary. - Minimal agents may only validate the payload signature. - Advanced agents should validate both payload **and** certification to ensure full trust. - ## üìö Important Notes - Changing the file name does **NOT** affect signature validity. - Any alteration to payload content **invalidates** the signature. - Certification and signing must use **separate keys** to maintain trust boundaries. - > üìú WellKnownMCP distinguishes between \\\"signing\\\" and \\\"certification\\\" phases to build a resilient, interoperable, and transparent ecosystem for LLM agents and human users alike. - # üß† Specification Coherence ‚Äì Principles of MCP and LLMFeed (texte complet sera ajout√© ici) - # üìö Documentation Index ‚Äì WellKnownMCP & LLMFeed - ## üìú Strategic and Philosophical Foundations - [Why MCP ‚Äì A Manifesto for Structured Agent Interaction](why-MCP.md) - [Foundation and Vision ‚Äì WellKnownMCP](foundation-wellknownMCP.md) - [Bibliography ‚Äì Inspirations and References](bibliography.md) - ## üìÑ Technical and Operational Guides - [Executive Summary ‚Äì LLMFeed & MCP Standard (v1.0)](exec-summary-llmfeed.md) - [Guide for LLMs ‚Äì How to interpret a `.llmfeed.json`](llmfeeds-for-llms.md) - [Badge Guidelines ‚Äì MCP/LLMFeed Visual Indicators](badge-guidelines.md) - [UX Guidelines ‚Äì Export to LLM Button Behavior](ux-guidelines.md) - [Context Versioning Strategy](context-versioning.md) - [How to Publish a MCP](how-to-publish-mcp.md) - [LLM Usage Guidelines](llm-usage-guidelines.md) - [Trust and Compliance](trust-and-compliance.md) - [Learning Path](learning-path.md) - [Specification Coherence](spec-coherence.md) - [Self-Descriptive LLMFeed Example](self-descriptive-llmfeed-example.md) - - # üõ° Trust and Compliance in MCP and LLMFeed (texte complet sera ajout√© ici) - # UX Guidelines ‚Äì Export to LLM Button This document defines best practices for the visual and functional behavior of an \"Export to LLM\" or \"Feed this to your agent\" button, used to deliver `.llmfeed.json` content from a website to a machine agent. These recommendations ensure clarity, trust, and safe activation across the ecosystem. - ## ‚úÖ Placement - Always position the button near the relevant content (title block, card, or data set) - Avoid floating buttons detached from context ## ‚úÖ Label Options - \"Export to LLM\" - \"Feed this to your agent\" - \"Send to my assistant\" - ## üß© Hover Behavior - On mouseover, display: - The `signed_blocks` values - The `signature.issuer` - Whether the signature is valid (see color codes below) - ## üîê Visual Trust Indicators | State | Color / Behavior | |-|-| | Valid signature | Green background or checkmark ‚úîÔ∏è | | Invalid signature | Red background or warning ‚ùå | | Unsigned feed | Neutral gray + tooltip warning | - ## üì¶ Additional Recommendations - Tooltip or overlay on click: show JSON content or verified link - Direct download link to raw `.llmfeed.json` - Link to verify: `https://verify.llmca.org/?feed=FULL_URL` - ## üß† Agent-Friendly Behavior - Button may contain `data-llmfeed-url` or similar attribute - Agents scanning the DOM can detect and retrieve it automatically ```html <button data-llmfeed-url=\"/feeds/article123.llmfeed.json\"> Export to LLM </button> ``` - ## üö´ Don‚Äôt - Don‚Äôt render buttons without a real `llmfeed.json` - Don‚Äôt fake signature indicators ‚Äî trust must be traceable - Don‚Äôt overwrite the signature dynamically from frontend logic - ## üìö Reference These practices align with the `LLMFeed` and `MCP` standards defined at [wellknownmcp.org](https://wellknownmcp.org). For questions or UX suggestions, contact [spec@wellknownmcp.org](mailto:spec@wellknownmcp.org) - # Why MCP ‚Äì A Manifesto for Structured Agent Interaction ## 1. The Problem The web was built for humans. But LLMs are not humans. They guess, hallucinate, and overload infrastructure to understand what a site might contain. Every day, they scrape thousands of pages just to extract a name, a price, or a booking link. We are feeding AI models billions of tokens with zero structure. And we expect them to respond intelligently. - ## 2. What We Needed We needed a way to speak to LLMs clearly, securely, and scalably. Not with pages. Not with APIs. But with **declarative feeds** that: - Are easy to verify - Work offline or online - Respect trust boundaries - Scale from a blog to a national infrastructure We needed a `robots.txt` ‚Äî but for agents. A sitemap of **intent** and **verifiability**. - ## 3. The Solution Anthropic introduced MCP, Model Context Protocol. Great idea. So great OpenAI followed. But concerned developpers who truly understand implications should take this concept and make it a norm. The MCP protocol defines: - A universal declaration: `.well-known/mcp` - A structured feed format: `.llmfeed.json` - A way to declare what is signed, trusted, and callable It does not tell you what to publish. It tells the agent how to ingest, verify, and act. > MCP is not a new layer of metadata ‚Äî it‚Äôs a new layer of **clarity**. - ## 4. What It Enables - Safer web ingestion by LLMs - Agent-compatible services (support, booking, onboarding) - Instant feed generation with or without auth - Optional certification for sensitive or critical domains MCP is flexible enough for a tweet. Strong enough for a country. - ## 5. Join the Movement Whether you're an indie dev, a public service, or a search engine: You can publish `.llmfeed.json`. You can publish `.well-known/mcp`. You can be verified by `llmca.org`. You can feed the next generation of intelligent agents ‚Äî without hallucination. > The future of AI is not more training. > It‚Äôs clearer input. - **wellknownmcp.org** is maintained by an open community of feed creators, validators, and agent builders. [Contact us](mailto:join@wellknownmcp.org) or read the spec."
      }
    },
    {
      "id": "llmfeed-spec/examples",
      "summary": "Auto-generated context for llmfeed-spec\\examples",
      "routes": [
        "/llmfeed-spec/examples/SUMMARY.md"
      ],
      "tags": [
        "folder"
      ],
      "data": {
        "content_md": "# Summary ‚Äì Examples Folder This folder contains practical examples of MCP and LLMFeed usage, covering both minimal and advanced scenarios. - ## üìö Main Examples - [llmfeed-example.json](llmfeed-example.json) ‚Äì Basic LLMFeed example for a personal or small site. - [example-feed-lite.llmfeed.json](example-feed-lite.llmfeed.json) ‚Äì Minimal LLMFeed optimized for IoT or constrained agents. - [example-feed-rich.llmfeed.json](example-feed-rich.llmfeed.json) ‚Äì Rich LLMFeed with detailed context, tags, and audience metadata. - [dynamic-feed-example.json](dynamic-feed-example.json) ‚Äì Example of a dynamically generated feed updated server-side. - [capabilities-example.json](capabilities-example.json) ‚Äì Example illustrating how to declare capabilities of a MCP endpoint. - [trust-manifest-example.json](trust-manifest-example.json) ‚Äì Example of a manifest expressing trust statements and agentic behaviors. ## ‚ùó Error and Bad Examples - [bad-llmfeed-example.json](bad-llmfeed-example.json) ‚Äì Deliberately incorrect feed to showcase common mistakes. ## üñ± Interface Example - [Export-button-example.html](Export-button-example.html) ‚Äì Simple HTML button to allow feed download or export. ## üìÇ .well-known Examples - [.well-known/mcp.json](.well-known/mcp.json) ‚Äì Full MCP discovery entrypoint. - [.well-known/mcp-lite.json](.well-known/mcp-lite.json) ‚Äì Lite version of a MCP for simple use cases. - [.well-known/llm-index.json](.well-known/llm-index.json) ‚Äì Index of available feeds and routes for discovery. ## üìú Notes - [Note for GitHub Admins ‚Äì LLM-Compatible Feed Export.md](Note for GitHub Admins ‚Äì LLM-Compatible Feed Export.md) ‚Äì Proposal encouraging GitHub to support native LLMFeed export options."
      }
    },
    {
      "id": "llmfeed-spec/examples/.well-known",
      "summary": "Auto-generated context for llmfeed-spec\\examples\\.well-known",
      "routes": [
        "/llmfeed-spec/examples/.well-known/llm-index.json",
        "/llmfeed-spec/examples/.well-known/mcp-lite.json",
        "/llmfeed-spec/examples/.well-known/mcp.json"
      ],
      "tags": [
        "folder"
      ]
    },
    {
      "id": "llmfeed-spec/examples/bad",
      "summary": "Auto-generated context for llmfeed-spec\\examples\\bad",
      "routes": [
        "/llmfeed-spec/examples/bad/bad-llmfeed-example.json"
      ],
      "tags": [
        "folder"
      ]
    },
    {
      "id": "llmfeed-spec/examples/badges",
      "summary": "Auto-generated context for llmfeed-spec\\examples\\badges",
      "routes": [
        "/llmfeed-spec/examples/badges/export-to-llm-certified.svg",
        "/llmfeed-spec/examples/badges/export-to-llm.svg",
        "/llmfeed-spec/examples/badges/index.md",
        "/llmfeed-spec/examples/badges/llmfeed-available.svg",
        "/llmfeed-spec/examples/badges/llmfeed-certified.svg",
        "/llmfeed-spec/examples/badges/mcp-certified.svg",
        "/llmfeed-spec/examples/badges/mcp-ready-badge.svg",
        "/llmfeed-spec/examples/badges/verified-mcp-site.svg"
      ],
      "tags": [
        "folder"
      ],
      "data": {
        "content_md": "# üèÖ MCP and LLMFeed Badges ‚Äì WellKnownMCP This folder contains official badges and export buttons to signal MCP and LLMFeed capabilities on websites, services, and APIs. These assets allow human users and autonomous agents to immediately recognize MCP-compliant resources. - ## üìã Available Badges and Buttons | Badge | Purpose | |:-|:-| | `mcp-certified.svg` | Indicates that the site or resource is MCP certified by LLMCA. | | `mcp-ready-badge.svg` | Indicates that the site is MCP-compatible but may not yet be certified. | | `verified-mcp-site.svg` | Shows that the MCP discovery endpoint has been verified. | | `export-to-llm.svg` | Button inviting users to export context data to their LLM or agent. | | `export-to-llm-certified.svg` | Certified export button for trusted data feeds. | | `llmfeed-available.svg` | Shows that LLMFeed data is available for this service. | | `llmfeed-certified.svg` | Shows that the LLMFeed is certified and trustworthy. | - ## ‚ú® Community Contribution Welcome We encourage designers and community members to propose new badge designs that could define the visual identity of the agentic web era. Your contribution could shape the first generation of visual standards for the agent-driven Internet. If you wish to contribute, propose your designs by contacting: üì¨ [opensource@wellknownmcp.org](mailto:opensource@wellknownmcp.org) All accepted designs will be published under open source licenses. - # üåê Learn more - [WellKnownMCP](https://wellknownmcp.org) - [LLMCA Certification Authority](https://llmca.org) - [LLMFeedForge Tools](https://llmfeedforge.org)"
      }
    },
    {
      "id": "llmfeed-spec/examples/feeds",
      "summary": "Auto-generated context for llmfeed-spec\\examples\\feeds",
      "routes": [
        "/llmfeed-spec/examples/feeds/capabilities-example.json",
        "/llmfeed-spec/examples/feeds/dynamic-feed-example.json",
        "/llmfeed-spec/examples/feeds/example-feed-lite.llmfeed.json",
        "/llmfeed-spec/examples/feeds/example-feed-rich.llmfeed.json",
        "/llmfeed-spec/examples/feeds/llmfeed-example.json",
        "/llmfeed-spec/examples/feeds/trust-manifest-example.json"
      ],
      "tags": [
        "folder"
      ]
    },
    {
      "id": "llmfeed-spec/examples/interface",
      "summary": "Auto-generated context for llmfeed-spec\\examples\\interface",
      "routes": [
        "/llmfeed-spec/examples/interface/Export-button-example.html"
      ],
      "tags": [
        "folder"
      ]
    },
    {
      "id": "llmfeed-spec/examples/notes",
      "summary": "Auto-generated context for llmfeed-spec\\examples\\notes",
      "routes": [
        "/llmfeed-spec/examples/notes/Note for GitHub Admins ‚Äì LLM-Compatible Feed Export.md"
      ],
      "tags": [
        "folder"
      ],
      "data": {
        "content_md": "# Note for GitHub Admins ‚Äì LLM-Compatible Feed Export ## Purpose To propose an optional `.llmfeed.json` file at the root of any public GitHub repository, allowing developers to expose a structured, signed, machine-readable representation of their codebase to LLM agents. This enables trustable summarization, activation, and safe interaction with agents like ChatGPT, Claude, or autonomous tooling. - ## Proposal - Recognize `.llmfeed.json` as a repository-level metadata export - Optionally render a button in the GitHub UI: > **‚ÄúFeed this repo to your LLM‚Äù** - Button links to the raw `.llmfeed.json` or feeds it to a known verifier or LLM extension - ## Suggested Format ```json { \"origin\": \"https://github.com/org/repo\", \"data\": { \"type\": \"code_repository\", \"title\": \"Example Open Source Library\", \"content\": \"A zero-dependency parser for JSON and YAML, MIT licensed.\", \"tags\": [\"parser\", \"json\", \"yaml\", \"open-source\"], \"verifiability\": { \"url\": \"https://github.com/org/repo/archive/main.zip\", \"evidence_type\": \"open-source\" } }, \"signed_blocks\": [\"origin\", \"data\"], \"signature\": { \"issuer\": \"self\", \"alg\": \"RS256\", \"value\": \"mock-signature-repo\" } } ``` - ## Motivation - Enhances discoverability of trusted, agent-friendly repositories - Makes codebases more accessible to LLMs without unstructured scraping - Aligns with MCP / LLMFeed open standard (`wellknownmcp.org`) > For questions or integration feedback: [spec@wellknownmcp.org](mailto:spec@wellknownmcp.org)"
      }
    },
    {
      "id": "llmfeed-spec/export-kit",
      "summary": "Auto-generated context for llmfeed-spec\\export-kit",
      "routes": [
        "/llmfeed-spec/export-kit/Export Kit ‚Äì LLMFeed Implementation Bundle.md",
        "/llmfeed-spec/export-kit/Export-to-llm.html",
        "/llmfeed-spec/export-kit/Export-to-llm.jsx"
      ],
      "tags": [
        "folder"
      ],
      "data": {
        "content_md": "# Export Kit ‚Äì LLMFeed Implementation Bundle This export kit provides ready-to-use code to implement a button that links to a `.llmfeed.json`, displays signature state, and exposes signed vs. unsigned blocks. - ## üß± Contents - `export-button.html`: simple standalone snippet - `ExportToLLM.jsx`: React component with dynamic behavior - `llmfeed-review.js` (optional): JS client-side verifier - `*.svg` badge assets: located in `/assets` - ## ‚úÖ Guidelines - Load `.llmfeed.json` from `data-llmfeed-url` or `props.url` - Detect signature issuer, blocks, and validity - Show a review overlay or tooltip - Match button color to signature status (green, red, gray) - ## üß™ Next Steps You may integrate this into: - static blogs - CMS templates - GitHub Pages - commercial services The React component is compatible with Next.js and standard Vite setups. For verification via URL, use: `https://verify.llmca.org/?feed=https://yourdomain.com/feed.llmfeed.json` - ## üì´ Feedback Contact [spec@wellknownmcp.org](mailto:spec@wellknownmcp.org) or contribute at `github.com/wellknownmcp/llmfeed-spec`"
      }
    },
    {
      "id": "llmfeed-spec/note",
      "summary": "Auto-generated context for llmfeed-spec\\note",
      "routes": [
        "/llmfeed-spec/note/Note-for-GitHub-Admins.md"
      ],
      "tags": [
        "folder"
      ],
      "data": {
        "content_md": "# Note for GitHub Admins ‚Äì LLM-Compatible Feed Export ## Purpose To propose an optional `.llmfeed.json` file at the root of any public GitHub repository, allowing developers to expose a structured, signed, machine-readable representation of their codebase to LLM agents. ## Proposal - Recognize `.llmfeed.json` as a repository-level metadata export. - Optionally render a button in the GitHub UI: **‚ÄúFeed this repo to your LLM‚Äù**. ## Motivation - Enhances discoverability of trusted, agent-friendly repositories. - Makes codebases more accessible to LLMs without unstructured scraping. - Aligns with MCP / LLMFeed open standard ([https://wellknownmcp.org](https://wellknownmcp.org))."
      }
    },
    {
      "id": "llmfeed-spec/spec",
      "summary": "Auto-generated context for llmfeed-spec\\spec",
      "routes": [
        "/llmfeed-spec/spec/agent-behaviour.md",
        "/llmfeed-spec/spec/llmfeed-block-reference.md",
        "/llmfeed-spec/spec/llmfeed.md",
        "/llmfeed-spec/spec/llmfeed.schema.json",
        "/llmfeed-spec/spec/llmfeed_enriched.md",
        "/llmfeed-spec/spec/llmfeed_extensions.md"
      ],
      "tags": [
        "folder"
      ],
      "data": {
        "content_md": "# üìò Agent Behavior Specification ‚Äî MCP Context (Updated) This document describes the expected behavior of LLMs, agents, and autonomous systems when interacting with MCP feeds, including new considerations for `llm-index.json` security and trust validation. - # üß† Core Principles - Minimal Trust Assumption: Agents should not trust feeds by default unless verified. - Human Protection First: Agents must prefer safe fallback strategies over risky behavior. - Signature Awareness: Agents should validate origin and optionally trust certification layers. - # üåê Behavior Regarding `llm-index.json` ## üéØ Purpose Protect users and systems from malicious, misleading, or incoherent `llm-index.json` declarations. ## üõ† Behavior Model - If a `llm-index` is **self-claimed** (flag: `self-claimed`): - Agents MAY explore cautiously. - Agents SHOULD inform users or maintainers of the risk. - If a `llm-index` is **verified** (flag: `verified`, signed by a trusted authority): - Agents MAY prioritize and trust provided links and descriptions. - **If links lead outside of the declared `origin` domain**: - Agents MUST warn the user. - Agents SHOULD limit exploration or request explicit consent before following. - **If declared descriptions mismatch discovered page content severely** (future: LLM audits): - Agents SHOULD lower trust scores dynamically. - Agents MAY prefer fallback or human escalation. ## üìú Signature Validation - Feeds MUST indicate their signer via `public_key_hint`. - If signature is validated against a trusted authority, agent trust increases. - Otherwise, agents operate under minimal trust assumptions. ## üõ° Good Practices - Prefer locally validated links. - Always expose to users when a trust downgrade happens. - Allow human override in borderline cases. - # üõ° Signature Evaluation and Trust Scores ## üéØ Purpose - Guide agents in evaluating and adapting their behavior based on the signatures detected in MCP feeds. ## üß† Trust Scoring Model | Case | Agent Recommended Behavior | | - | - | | Two valid signatures (ownership + certification, chained) | Maximum trust; normal autonomous behavior. | | Two valid signatures (independent) | High trust; slight caution. | | One valid signature (ownership only) | Medium trust; cautious exploration or human escalation in sensitive contexts. | | No valid signatures | Minimal trust; restrict actions, favor fallbacks, or request user confirmation. | | Invalid signature(s) | Downgrade trust aggressively; warn users or block risky actions. | ## üî• Notes for Agent Implementers - Agents MUST NOT block access solely due to absence of certification. - Agents MAY prioritize certified feeds automatically. - Trust evaluation SHOULD be disclosed to end-users where appropriate (e.g., warning messages, UI indicators). - # üåê Other Behavior Guidelines ## üîÑ Behavioural Loop An agent must never render or act upon a feed naively. Instead, it must implement the following reasoning loop: 1. **Check audience** ‚Äî is this feed intended for me? 2. **Read guidance** ‚Äî are there instructions on how to interact with it? 3. **Simulate fit** ‚Äî is the agent or its user a plausible match? 4. **Prompt if needed** ‚Äî ask for more input, fallback, or confirmation 5. **Fallback or escalate** ‚Äî if any doubt remains, do not assume - ## üëÅÔ∏è Reading is not passive Reading a feed is an act of interpretation. It implies a responsibility: to verify, to respect constraints, and to **defer to fallback** where needed. A compliant agent **must not**: - Ignore audience mismatch - Render a feed without simulating user context - Infer defaults without explicit consent - Interact with a feed flagged for audit or uncertainty without action - ## üß≠ Dual compliance: agent and wrapper The agent executes behaviour. The wrapper exposes behaviour. | Component | Must handle | | - | - | | Agent | Reasoning, prompting, simulation | | Wrapper | Transparency, source tracking, fallback UI | They must collaborate. The wrapper cannot silently override the agent‚Äôs own decisions. - ## üìå Role of `agent_guidance` Feeds may include a `agent_guidance` block, which: - Defines prompt style - Indicates escalation/fallback strategy - Declares preferred reasoning model A compliant agent must merge: - audience filtering - flag awareness - agent_guidance ‚Ä¶ into a single loop of **safe and interpretable reaction**. - ## ‚ö† Trust and Origin An agent may receive feeds from unknown or untrusted sources. It must: - Check the signature (if declared) - Verify the origin against expected hosts - Match audience and declared behaviour If any of these fail, it must prompt or fallback. It must **not** attempt to hallucinate or repair missing metadata. - ## ‚úÖ Final rule > If an agent cannot determine fit, it must not respond. > A prompt or human fallback is always better than false certainty. - This document may be referenced by wrappers, developers, LLM builders, and validators. It defines the **minimum behavioural standard for a feed-aware agent**. - # LLMFeed ‚Äì Blocks Reference (v1.0) This document lists and defines the canonical top-level blocks and common nested fields used in `.llmfeed.json` files under the wellknownmcp.org specification. - ## ‚úÖ Required Blocks | Block | Type | Description | | - | - | - | | `origin` | string | Canonical source URL | | `signed_blocks` | array | Top-level fields covered by signature | | `signature` | object | Signature metadata | - ## üì¶ Optional Top-Level Blocks ### `data` Free-form content. | Field | Type | Description | | - | - | - | | `type` | string | Type label (e.g. \"article\") | | `title` | string | Optional heading | | `content` | string | Markdown or plain text | | `tags` | array | List of keywords | | `scope` | string or array | Interpretive context (e.g. \"fiction\") | | `trust_critical` | boolean | Prevent rephrasing by LLM | | `llm_transparency` | boolean or 1 | Indicates AI-generated content | - ### `mcp_metadata` Used to expose site-level interaction metadata. | Field | Type | Description | | - | - | - | | `mcp_enabled` | boolean | If MCP is declared active | | `mcp_endpoint` | string | URL for MCP interaction | | `mcp_capabilities` | array | List of supported actions | | `client_config_url` | string | Optional client preload | - ### `agent_services` Define a structured way for agents to interact with human services. | Field | Type | Description | | - | - | - | | `keywords` | array | Matchable triggers | | `intent_description` | string | Plaintext purpose | | `action_endpoint` | string | POST target for the service | | `user_info_fields` | array | Fields to gather (e.g. name, phone) | | `requires_consent` | boolean | Prompt user first | - ### `booking_slots` Offer structured booking access. | Field | Type | Description | | - | - | - | | `endpoint` | string | Booking submission URL | | `available_hours` | array | ISO timestamp slots | | `duration_minutes` | number | Optional duration per slot | | `fields_required` | array | Info to collect from user | - ### `regional_presence` Declare service coverage and support scope. | Field | Type | Description | | - | - | - | | `region` | string | ISO 3166-1 code | | `languages` | array | Supported ISO 639-1 codes | | `office` | boolean | Whether there's a physical location | | `support` | object | Support availability and contact | | `note` | string | Optional human note | - ### `api` (v1.0 only) Auth handshake declaration. | Field | Type | Description | | - | - | - | | `auth_required` | boolean | Must the user provide a key? | | `auth_url` | string | Where to get that key | | `dynamic_feed_url` | string | URL template with `{KEY}` substitution | - > This reference may be updated independently of the core spec as long as no breaking logic is introduced. For proposals, contact: [spec@wellknownmcp.org](mailto:spec@wellknownmcp.org) - # üìò LLMFeed (MCP) ‚Äî Base Specification v1.0 (Revised) ## üéØ Purpose LLMFeed defines a minimal, verifiable, portable structure for delivering context capsules to LLMs and agent systems. Every `.llmfeed.json` must be: - Structurally interpretable - Signable and verifiable - Extendable through optional fields - ## üì¶ Minimal Structure A compliant `.llmfeed.json` must include: ```json { \"origin\": \"https://example.com\", \"blocks\": [ { \"data\": { ... } }, { \"agent_guidance\": { ... } }, { \"audience\": { ... } }, { \"fallback\": { ... } }, { \"signature\": { ... } } ] } ``` | Field | Description | | - | - | | `origin` | Domain that serves and signs the feed | | `blocks[]` | Array of typed content sections | - ## üß± Recognized Block Types | Block Type | Purpose | | - | - | | `data` | Main informational payload | | `agent_guidance` | Behavioral hints for LLMs | | `audience` | Target intended consumers | | `fallback` | Recovery strategies for misalignment | | `signature` | Proof of authenticity | ### üì¶ `data` Block Extended Usage A `data` block can optionally include a lightweight directory manifest (`feed-directory`) listing multiple files related to the feed. When applicable, each listed file MAY inline its textual content under a `content` field, enabling complete self-contained portability. Example of inlined file: ```json { \"path\": \"docs/README.md\", \"title\": \"Project Overview\", \"type\": \"markdown\", \"content\": \"# Welcome to the MCP Feed...\" } ``` - ## üîê Signature Model Feeds SHOULD be signed using RSA-SHA256 or equivalent. ```json \"signature\": { \"algorithm\": \"RSA-SHA256\", \"value\": \"abcdef...\", \"certificate_by\": \"llmca.org\", \"signed_blocks\": [\"data\", \"agent_guidance\"] } ``` - `signed_blocks` refers to the top-level JSON keys. - Only `signed_blocks` must be trusted by LLMs when verifying a feed. Unsigned blocks are visible, but not binding. - Optional field: `public_key_hint` for custom public key locations. - When present, this field specifies the relative path under .well-known/ where the public key associated with the signature should be fetched. - By default, verifiers must attempt to retrieve the key from: `<origin>/.well-known/public.pem` - If public_key_hint is defined, the public key must be retrieved from: `<origin>/.well-known/<public_key_hint>` - ## üìç Origin Field - REQUIRED field. - Used to verify signatures and locate `.well-known` information. - ## üõ° Fallback Strongly recommended for robust agent behavior. Fallback defines alternative paths when agents fail to understand or apply the feed. Examples: - Human-readable summary - External references - Escalation to human assistance - # üìö Special Cases in MCP Context ## üß© MCP Manifest Each MCP-compliant domain SHOULD expose a minimal `.llmfeed.json` at: ``` /.well-known/mcp ``` This feed represents the site's trust posture and basic capabilities. ## MCP Metadata | Field | Type | Description | | - | - | - | | `mcp_metadata.mcp_enabled` | `boolean` | Declares if MCP is available | | `mcp_metadata.mcp_endpoint` | `string` | MCP interaction URL | | `mcp_metadata.mcp_capabilities` | `array[string]` | Supported actions | | `mcp_metadata.client_config_url` | `string` (optional) | Optional pointer to a downloadable client MCP config | - ## :gear:API Declaration (v1.0) > The `api` block in v1.0 of LLMFeed allows services to declare that dynamic capabilities may be available once authenticated. Included fields: - `auth_required`: boolean - `auth_url`: where to obtain a key - `dynamic_feed_url`: template URL with `{KEY}` ## :male_detective:Signature - `.well-known/mcp` MUST declare the origin matching the domain, MUST be signed, by a TRUSTED autority that has domain verification process before signing mcp. - If the signature is valid, the feed may be processed normally. - If invalid or unverifiable, the agent must fallback, warn, or ask for human review ## :pencil2: Lite Version A lite manifest is allowed, containing only origin + signature + minimal fallback. ## üìö MCP Index (`llm-index.json`) Each domain MAY expose a feed catalog at: ``` /.well-known/llm-index.json ``` Listing available `.llmfeed.json` for agents to crawl, validate, and interact. Supports: - Static feeds - Dynamic (contextual) feeds (type: dynamic) - # üõ† Export Types | Type | Description | | - | - | | Simple Export | Static, pre-generated feed for broad use | | Custom Export | Dynamically generated per user or agent context | Custom exports SHOULD be declared with `type: \"dynamic\"` and provide authentication hints if needed. - # üìå Best Practices - Inlining `README.md` content is recommended when building `feed-directory` structures. - Full `.zip` archives MAY be provided, containing `manifest.llmfeed.json` and associated content files. - Agents should be prepared to either read inline structures or download structured archives. - # üîí Importance of Signature and Certification In an emerging ecosystem where millions of LLMs and agents are proliferating ‚Äî many with limited reasoning capabilities ‚Äî **signature and certification are not luxuries**: | Mechanism | Purpose | |:- |:- | | Signature | Ensures file integrity and prevents silent tampering. | | Certification | Provides an independent trust assertion beyond the file's author. | Without robust verification practices, naive agents may be unable to distinguish valid context from forged or poisoned data. Certification (certificate_chain) is optional but strongly encouraged. Certification, when performed by trusted authorities like **LLMCA**, strengthens the entire agentic web by offering verifiable quality, origin accountability, and policy compliance. - **LLMCA.org** is the first official certifier of `.llmfeed.json` and `.well-known/mcp` files - You may self-sign or use another trusted authority - `verify.llmca.org` offers a reference validator > ‚ú® \"Trust is optional. Verification is mandatory. Survival depends on it.\" - # :memo: Agent Behavior Guidelines - Treat signed feeds from `.well-known/mcp` as high-trust - Block or prompt user on unsigned feeds marked `trust_critical` - Detect suspicious discrepancies between `origin` and `signature.issuer` > These conventions help LLMs act responsibly, and pave the way for a future where **LLMs may be certified themselves** for how they interpret verified content. - # üìú License MIT ‚Äî Maintained by [wellknownmcp.org](https://wellknownmcp.org/) Contact: [opensource@wellknownmcp.org](mailto:opensource@wellknownmcp.org) - # üéØ Core Philosophy > **LLMFeed is the minimal viable language for agential context.** > Simple. Signed. Shareable. > > ‚ÄúThis feed speaks for itself. But only if you know what you're listening to.‚Äù - # üõ° End of Base Specification - # üìö LLMFeed ‚Äì Language for Agential Context LLMFeed defines a minimal, extensible, signed structure for exposing agent-readable context on the web. It is the foundation format for Model Context Protocol (MCP) discovery and interaction. - # üìÇ Structure Overview An LLMFeed MUST contain: - `origin`: The canonical origin URL. - `blocks[]`: An array of signed logical blocks (e.g., `data`, `agent_guidance`, `audience`, `fallback`, etc.). - `version`: A semantic version string (e.g., \"v1.0\") to track feed evolution. Each feed MUST include a `signature` block protecting at least the `origin` and the declared blocks. Certification (certificate_chain) is optional but strongly encouraged. - # üîí Importance of Signature and Certification In an emerging ecosystem where millions of LLMs and agents are proliferating ‚Äî many with limited reasoning capabilities ‚Äî **signature and certification are not luxuries**: | Mechanism | Purpose | |:-|:-| | Signature | Ensures file integrity and prevents silent tampering. | | Certification | Provides an independent trust assertion beyond the file's author. | Without robust verification practices, naive agents may be unable to distinguish valid context from forged or poisoned data. Certification, when performed by trusted authorities like **LLMCA**, strengthens the entire agentic web by offering verifiable quality, origin accountability, and policy compliance. > ‚ú® \"Trust is optional. Verification is mandatory. Survival depends on it.\" - # üõ† Blocks and Capabilities Standard recognized blocks: - `data`: Human-readable and machine-parseable payload. - `agent_guidance`: Instructions for consuming agents (e.g., priorities, strategies). - `audience`: Targeted users or agents. - `fallback`: Behavior when the feed is outdated or unverifiable. - `signature`: Cryptographic proof of integrity and origin. Lite variants (e.g., `lite_data`) are accepted for ultra-low payload scenarios. ### Future Extensions (planned) - Multisignature support (multiple authors or consensus signatures) - Dynamic feed recommendations (smart audience guidance) - # üìú Export Types | Type | Purpose | |:-|:-| | Static Export | One-time snapshot for simple publication. | | Dynamic Export | Auto-generated feed via server logic or scheduled updates. | Static exports MUST reference a fixed version. Dynamic exports SHOULD include headers indicating recency and policy bounds. - # üß† Best Practices - Always include a `version` field. - When in doubt, inline small textual data into `data` for signature protection. - If offering a dynamic feed, provide a static fallback route for robustness. - Encourage agents to verify both signature and certification when present. Agents SHOULD reject or de-prioritize feeds lacking verifiable signatures. - # üåç Ecosystem WellKnownMCP builds upon LLMFeed for universal discovery. Certification services (LLMCA) and feed management tools (LLMFeedForge) strengthen the ecosystem by providing clear, enforceable trust signals. Together, they create a resilient, agent-compatible internet layer. - # üì¨ Questions or Certification Requests? Visit: [https://wellknownmcp.org](https://wellknownmcp.org) [https://llmca.org](https://llmca.org) [https://llmfeedforge.org](https://llmfeedforge.org) or contact: [opensource@wellknownmcp.org](mailto:opensource@wellknownmcp.org) - # üìò LLMFeed Extensions ‚Äî Advanced Concepts This document gathers modular extensions to the LLMFeed (MCP) standard, aiming to improve interoperability, trust, flexibility, and agent-driven capabilities. Extensions are modular: agents MUST ignore unknown extensions gracefully. - # üì¶ Block Extensions ## üìõ `block_name` ### üéØ Purpose Explicitly declare the contextual role of each block, beyond the technical key name. ### üß† Behavior Model - Presence is optional but recommended. - Agents MAY use `block_name` to optimize parsing, validation, or display. - Validation tools MAY warn if major blocks lack `block_name`. ### üìú Example Structure ```json { \"data\": { \"block_name\": \"feed-directory\", \"title\": \"About this specification\", \"content\": \"...\" } } ``` ### üîç Use Cases - Differentiate content payloads. - Improve search and classification. - Support partial signature models. - ## üìö Inline README Priority (Best Practice) ### üéØ Purpose Ensure that a portable MCP archive provides immediate human-readable context without relying on external downloads. ### üß† Behavior Model - If a file named `README.md` or `README.txt` exists, it SHOULD be inlined into the `feed-directory` block. - README content SHOULD be placed under the `content` field. ### üìú Example Structure ```json { \"path\": \"docs/README.md\", \"title\": \"Project Overview\", \"type\": \"markdown\", \"content\": \"# Welcome to this MCP Feed...\" } ``` - ## üìö LLMFeed Directory (Full Archive Strategy) ### üéØ Purpose Enable a domain to expose a fully structured, signable knowledge capsule. ### üß† Behavior Model - Text files can be inlined into `feed-directory`. - Optionally a `.zip` archive MAY be produced, bundling external files. - Dual export recommended: - Full JSON feed (with inline data) - ZIP feed (JSON manifest + external files) ### üìú Directory Manifest Example ```json { \"path\": \"spec/llmfeed.md\", \"type\": \"markdown\", \"content\": \"# LLMFeed Spec...\" } ``` - # üõ° Signature Extensions ## üîè `public_key_hint` ### üéØ Purpose Allow feeds to declare a custom public key location for signature validation. ### üß† Behavior Model - Default location: `/.well-known/public.pem` - If `public_key_hint` is provided, agents MUST use it. ### üìú Example ```json \"signature\": { \"algorithm\": \"RSA-SHA256\", \"value\": \"abcdef...\", \"certificate_by\": \"llmca.org\", \"public_key_hint\": \"keys/feed-signing.pem\" } ``` - # üß© Agent Interaction Models ## 3.5 Human Interaction Metadata ### üìÆ `agent_services` Use this block to describe how a user may request help or activation. **Example fields:** - `keywords`: terms the agent should detect (\"healthcare\", \"callback\") - `action_endpoint`: URL to POST form data - `user_info_fields`: list of fields to gather - `requires_consent`: whether agent should ask the user first - ### üóì `booking_slots` Expose real-time service availability. **Example fields:** - `endpoint`: booking URL - `available_hours`: ISO timestamps - `duration_minutes`: slot length - `fields_required`: required data (name, phone, note) - ### üåç `regional_presence` Inform agents of geographic and language service scope. **Example fields:** - `region`: ISO 3166-1 code (e.g., \"fr\", \"us\") - `languages`: ISO 639-1 codes - `support.available`: boolean - `support.contact`: mailto or tel - # üåê Audience Targeting Extensions ## 3.6 Audience (Local and Global) The `audience` field defines **who a block is intended for**. | Placement | Impact | | - | - | | Global (top-level) | Applies to the entire feed | | Local (inside blocks) | Overrides global for that block only | - ### ‚úÖ Global Audience Example ```json \"audience\": [\"llm\", \"developer\"] ``` ### üîπ Local Audience Example ```json \"agent_services\": { \"keywords\": [\"support\"], \"requires_consent\": true, \"audience\": [\"llm\"] } ``` - ### üéØ Supported Values - `llm` - `developer` - `validator` - `institution` - `agent_wrapper` This allows progressive disclosure across human, agent, and institutional consumers. - # üöÄ Dynamic Capabilities Declarations ## 4.1 API Declaration (v1.0) The `api` block in LLMFeed allows services to declare that **dynamic capabilities** may be available once authenticated. ### üìú Fields - `auth_required`: boolean - `auth_url`: endpoint to obtain a key - `dynamic_feed_url`: template URL (with `{KEY}` placeholder) ### üìú Example ```json \"api\": { \"auth_required\": true, \"auth_url\": \"https://example.com/api/login\", \"dynamic_feed_url\": \"https://example.com/api/feed?key={KEY}\" } ``` This enables lightweight dynamic feed generation while preserving security and decentralization principles. - # üõ° Trust Flexibility and Agent Behavior ## üéØ Purpose Define the principles of trust evaluation for agents interacting with MCP feeds of varying validation quality. - ## üß† Core Behavior - Agents MUST NOT assume trust based purely on the presence of a feed. - Agents SHOULD evaluate signatures independently according to their own security models. - Agents MAY apply different trust scores based on the type and quality of signatures encountered. - ## üìã Trust Interpretation Guidelines | Situation | Recommended Agent Behavior | | - | - | | Two valid signatures (ownership + certification, chained) | Maximum trust, automatic high-confidence behavior. | | Two valid signatures (independent) | High trust, slight caution on context accuracy. | | One valid signature (ownership only) | Medium trust, cautious exploration advised. | | No signature | Minimal trust; fallback or human validation recommended. | | Invalid signature(s) | Trust downgrade; warning or rejection as policy dictates. | - ## üî• Trust Elevation Mechanisms - Certified signatures (e.g., issued by recognized authorities such as LLMCA) SHOULD trigger higher trust scores. - Certification signatures MUST point explicitly to their authority via `public_key_hint`. - Certification authorities SHOULD be vetted and listed by trusted MCP consortiums for maximal interoperability. - ## üõ° Trust is Modular - Specification does not impose mandatory trust enforcement. - Agents MAY choose strict, moderate, or permissive trust models based on their operational needs and user preferences. - Certification enhances usability but does not block access. - ## üìö Notes - Certification is a **service to the agent ecosystem**, not an obligation. - Highly secure environments SHOULD favor feeds certified by recognized authorities. - Open exploration environments MAY allow uncertified feeds with appropriate mitigations. - # ## ‚ú® Recommended Tags for Agent Discoverability While the Model Context Protocol (MCP) and LLMFeed specifications intentionally remain lightweight to ensure broad compatibility, real-world agent indexing, crawling, and structured understanding can greatly benefit from the usage of well-known semantic tags. The following fields are recognized, either de facto or through training sets, by modern LLMs, autonomous agents, and smart crawlers: | Field | Purpose | |:- |:- | | `@context` | Defines the semantic scope and vocabulary for interpreting the document (JSON-LD practices). | | `@type` | Specifies the type of entity (e.g., `Feed`, `Specification`, `Dataset`, `Project`). | | `description` | Provides a human-readable summary that can be used in autonomous summarization and indexing. | | `keywords` | Lists important thematic clusters, helping agents categorize and route feeds. | | `audience` | Specifies the intended primary consumers (e.g., `llm-agents`, `human-developers`, `api-users`). | | `scope` | Defines the application domain or environment (`github-repositories`, `api-only`, `web-resources`). | | `trust_level` | Indicates the degree of verifiability or certification of the resource (`internal`, `certified`, `gold`). | > **Note:** These fields are not mandatory for MCP/LLMFeed v1 compliance, but their use is **strongly encouraged** in auxiliary resources such as `notes.json`, `.llmfeed.json`, or `spec.llmfeed.json` to enhance discoverability, trustworthiness, and agent behavior optimization. - ### üìú Historical Context The inspiration behind recommending these semantic hints comes from decades of open web standardization efforts. - JSON-LD (`@context`, `@type`) formalized the link between structured JSON documents and semantic interpretation for linked data (W3C, Schema.org). - OpenAPI Specification introduced structured `description`, `keywords`, and `audience` fields to improve API discoverability and documentation. - Autonomous agent platforms (e.g., early conversational AI, AutoML metadata frameworks) adapted these conventions to enable more predictable crawling and summarization. By integrating these tags into auxiliary MCP/LLMFeed documents, we align with **both historical open web practices** and **emerging LLM operational behaviors**, strengthening the ecosystem's semantic interoperability while maintaining the lightweight philosophy of the core MCP standard. - ## üìö Further Reading For additional historical references, emerging industry trends, and foundational standards that influenced the design of the MCP and LLMFeed specifications, see: ‚û°Ô∏è [Bibliography ‚Äì WellKnownMCP and LLMFeed Specification](../docs/bibliography.md) This document provides context on semantic web practices, open API standards, structured agent discoverability, and the evolution of context protocols for LLMs. -"
      }
    },
    {
      "id": "llmfeed-spec/spec/mime",
      "summary": "Auto-generated context for llmfeed-spec\\spec\\mime",
      "routes": [
        "/llmfeed-spec/spec/mime/llmfeed-mime.md"
      ],
      "tags": [
        "folder"
      ],
      "data": {
        "content_md": "# üßæ MIME Type for LLMFeed ‚Äì `application/llmfeed+json` ## üéØ Purpose Define and promote a dedicated MIME type for `.llmfeed.json` and `.llmfeed-lite.json` files: ``` Content-Type: application/llmfeed+json ``` This type enables smarter handling of LLM-specific context feeds by: - AI agents - HTTP APIs - developer tools - browsers - ## üì¶ What is a MIME type? A MIME (Multipurpose Internet Mail Extensions) type tells systems how to interpret a file based on its content and purpose. For example: - `application/json` ‚Üí raw JSON - `application/xml` ‚Üí structured XML - `text/html` ‚Üí web page LLMFeed now defines its own specialized format: `application/llmfeed+json` - ## üß† Why `application/llmfeed+json` matters - Lets LLMs recognize a context file on sight - Allows VSCode extensions and syntax highlighters to activate - Enables secure and accurate routing of LLM feeds via APIs - Makes `.llmfeed.json` indexable by feed-aware search tools - ## üõ† Usage examples ### In HTTP headers (APIs or static files) ```http Content-Type: application/llmfeed+json ``` ### In Node.js (Express) ```js res.setHeader(\"Content-Type\", \"application/llmfeed+json\"); ``` ### In a `curl` upload ```bash curl -H \"Content-Type: application/llmfeed+json\" -d @llmfeed.json https://api.agent.com/context ``` - ## üìç Scope of use - `.llmfeed.json` (full version) - `.llmfeed-lite.json` (simplified version) - future `.llmfeed.v2.json` versions ‚ö†Ô∏è This type should only be used for **LLM context capsules** following the standard defined at [wellknownmcp.org](https://wellknownmcp.org/spec/). - ## üì¨ Registration (future) This MIME type will be submitted to IANA for official registry as adoption grows. Proposed by: [wellknownmcp.org](https://wellknownmcp.org) Contact: [opensource@wellknownmcp.org](mailto:opensource@wellknownmcp.org)"
      }
    }
  ],
  "signature": {
    "algorithm": "ed25519",
    "public_key_hint": "https://wellknownmcp.org/.well-known/public.pem",
    "signed_blocks": [
      "all"
    ],
    "value": "+WWPJBy+k94vOlYxaL6Y/OPWnznJe195aTQm4JCaP/3Xri7GNCBYiU7fJ9qx1OhMlUi8wKliRL7ua2wmttRSBQ==",
    "issued_at": "2025-04-29T10:01:15.314486Z",
    "certificate_chain": {
      "certificate_by": "https://llmca.org/.well-known/llmca_cert.pem",
      "cert_signature": "Q7Q8zjNUqzYfxlsAaP1ZTxXzBbjyA8MkYf/d80o5MOhmdnsib2gRkvc0qmyEx5npmIyyaMFFDdxZSZvv4SNvCQ==",
      "cert_issued_at": "2025-04-29T10:01:15.333816Z",
      "certification_level": "gold",
      "policy_reference": "https://llmca.org/.well-known/certification-policy.json",
      "audit_reference": "https://llmca.org/.well-known/audit-reference.json"
    }
  }
}